<!doctype html>
<html>
        <head>
                <meta charset="utf-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

                <title>No Runtime Reflection No ORM</title>


                <link rel="stylesheet" href="css/reveal.css">
                <link rel="stylesheet" href="css/theme/league.css">

                <!-- Theme used for syntax highlighting of code -->
                <link rel="stylesheet" href="lib/css/zenburn.css">
                <style>
                    h1,h2, h3 {
                      font-family: fantasy!important;
                    }
                    section > p {
                        text-align: left;
                        font-size: 24px !important;
                        font-family: Garamond !important;
                        margin: 5px 0 !important;
                    }
                    .reveal pre code {
                        max-height: 600px;
                    }

                </style>

                <!-- Printing and PDF exports -->
                <script>
                        var link = document.createElement( 'link' );
                        link.rel = 'stylesheet';
                        link.type = 'text/css';
                        link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
                        document.getElementsByTagName( 'head' )[0].appendChild( link );
                </script>
        </head>
        <body>
                <div class="reveal">
                        <div class="slides">

  <section>
    <h1 style="position:relative; width:120%; left:-12%; font-family: initial !important;">C++ Intrudoction</h2>
    <p>Part 1</p>
    <p>&lt;<a href="https://twitter.com/amin_roosta">@amin_roosta</a>&gt;</p>
  </section>
  <section>
    <h2>Disclaimer</h2>
    <img src="lock-free.gif" style="zoom:70%; border:none" />
    <aside class="notes">My mental model of a full featured ORM.</aside>
  </section>

  <section>
      <p>Variable initialization & Assignment</p>
    <pre><code class="c++" data-noescape>
int main() {
    int a = 1;
    int b(2); // same as "int b = 2;"
    int c{3}; // same as "int c = 3;"

    int d = b + c;  // = used for initialization
    d = a;          // = used for assignment

    const int e{0}; // non modifiable variable
    ++e; // Error

    return 0;
}
    </code></pre>
  </section>

  <section>
      <p>Literals</p>
    <pre><code class="c++" data-noescape>
int main() {
    int i = 123;
    float f = 1.23f;
    double d = 1.23;

    int i2 = 123456;
    int i3 = 123'456; // you can use ' for readablity

    bool b = i2 == i3; // true
}
    </code></pre>
  </section>

  <section>
      <p>Strings<p>
    <pre><code class="c++" data-noescape>
#include&lt;string&gt;
#include&lt;iostream&gt;

using namespace std;
int main() {
    const string a{"one"}; // const string a = "one";
    const float f = 1.23f;

    string b = a;
    b += to_string(f);
    cout &lt;&lt; b &lt;&lt; endl; // one1.230000

    return 0;
};

    </code></pre>
    <p> - Always use const for const variables! </p>
    <p> - Use = for premitive types. </p>
    <p> - Use {} to intialized user defined types. </p>
  </section>

  <section>
      <p>References</p>
    <pre><code class="c++" data-noescape>
void by_value(int x) {
    ++x;
}

void by_reference(int&amp; x) {
    ++x;
}

void by_const_reference(const int&amp; x) {
    ++x; // Error!
}

int main() {
    int a = 0;
    by_value(a);     // a = 0
    by_reference(a); // a = 1
    return 0;
}
    </code></pre>
    <p> - Use by value (T t) for premitive types. </p>
    <p> - Use const reference (const T&amp; t) for user defined types. </p>
  </section>

  <section>
      <p>Using vector&lt;T&gt;<p>
    <pre><code class="c++" data-noescape>
#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

int main() {
    vector&lt;int&gt; w{3};   // { 0, 0, 0 }
    w.pop_back();       // { 0, 0 }

    vector&lt;int&gt; x{4, 1}; // { 1, 1, 1, ,1 }

    vector&lt;int&gt; y = { 1, 2, 3, 4 }; // { 1, 2, 3 }
    y.push_back(5);                 // { 1, 2, 3, 4 }

    int sum_y = 0;
    for(size_t idx = 0; idx &lt; y.size(); ++idx) {
        sum_y += y[idx];
    }

    sum_y = 0;
    for(int e : y) {
        sum_y += e;
    }
    
    return 0;
}
    </code></pre>
  </section>

  <section>
      <p>Example<p>
    <pre><code class="c++" data-noescape>
#include&lt;iostream&gt; // preprocess directive
#include&lt;vector&gt;    // bring vector declarations

using namespace std; // make everthing in standard namespace visible
double average(const vector&lt;int&gt; &amp; vec) {
    int total = 0;
    for(int e : vec) {
        total += e;
    }
    return vec.size() ? static_cast&lt;double&gt;(total) / vec.size() : 0;
}
int main() { // program entry
    const vector&lt;int&gt; vec = { 1, 2, 3, 4, 5};
    cout &lt;&lt; average(vec) &lt;&lt; endl; // output: 3
    return 0;
}
    </code></pre>
  </section>

  <section>
      <p>classes</p>
    <pre><code class="c++" data-noescape>
#include&lt;iostream&gt;
#include&lt;string&gt;

class User {
private:
    int _age;
    std::string _name;
public:
    User(std::string name, int age)
        : _age{age}, _name{name} { // initializer list after :
            
    }

    void print() const {
        std::cout &lt;&lt; '{' &lt;&lt; _name &lt;&lt; ',' &lt;&lt; _age &lt;&lt; '}' &lt;&lt; std::endl;
    };
};

int main() {
    const User user{"user", 20};
    user.print(); // {user,20}
    return 0;
}
    </code></pre>
  </section>

  <section>
      <p><i>Option pricing!</i></p>
    <pre><code class="c++" data-noescape>
int main() {
    // First we create the parameter list
    double S = 100.0;  // Option price
    double K = 100.0;  // Strike price
    double r = 0.05;   // Risk-free rate (5%)
    double v = 0.2;    // Volatility of the underlying (20%)
    double T = 1.0;    // One year until expiry

    // Then we calculate the call/put values
    double call = call_price(S, K, r, v, T);
    double put = put_price(S, K, r, v, T);

    // Finally we output the parameters and prices
    std::cout &lt;&lt; "Underlying:      " &lt;&lt; S &lt;&lt; std::endl;
    std::cout &lt;&lt; "Strike:          " &lt;&lt; K &lt;&lt; std::endl;
    std::cout &lt;&lt; "Risk-Free Rate:  " &lt;&lt; r &lt;&lt; std::endl;
    std::cout &lt;&lt; "Volatility:      " &lt;&lt; v &lt;&lt; std::endl;
    std::cout &lt;&lt; "Maturity:        " &lt;&lt; T &lt;&lt; std::endl;

    std::cout &lt;&lt; "Call Price:      " &lt;&lt; call &lt;&lt; std::endl;
    std::cout &lt;&lt; "Put Price:       " &lt;&lt; put &lt;&lt; std::endl;

    return 0;
}
    </code></pre>
  </section>

  <section>
    <p>Standard normal probability density function</p>
    <pre><code class="c++" data-noescape>
#include &lt;iostream&gt;
#include &lt;cmath&gt;

double norm_pdf(double x) {
    return (1.0/(pow(2*M_PI,0.5)))*exp(-0.5*x*x);
}
    </code></pre>
    <pre class="fragment"><code class="c++" data-noescape>
// Usefull constants defined in &lt;cmath&gt;
#define M_E         2.71828182845904523536028747135266250   /* e              */
#define M_LOG2E     1.44269504088896340735992468100189214   /* log2(e)        */
#define M_LOG10E    0.434294481903251827651128918916605082  /* log10(e)       */
#define M_LN2       0.693147180559945309417232121458176568  /* loge(2)        */
#define M_LN10      2.30258509299404568401799145468436421   /* loge(10)       */
#define M_PI        3.14159265358979323846264338327950288   /* pi             */
#define M_PI_2      1.57079632679489661923132169163975144   /* pi/2           */
#define M_PI_4      0.785398163397448309615660845819875721  /* pi/4           */
#define M_1_PI      0.318309886183790671537767526745028724  /* 1/pi           */
#define M_2_PI      0.636619772367581343075535053490057448  /* 2/pi           */
#define M_2_SQRTPI  1.12837916709551257389615890312154517   /* 2/sqrt(pi)     */
#define M_SQRT2     1.41421356237309504880168872420969808   /* sqrt(2)        */
#define M_SQRT1_2   0.707106781186547524400844362104849039  /* 1/sqrt(2)      */
    </code></pre>
  </section>

  <section>
    <p>cumulative distribution function</p>
    <pre><code class="c++" data-noescape>
// An approximation to the cumulative distribution function
// for the standard normal distribution
// Note: This is a recursive function
double norm_cdf(double x) {
    const double k = 1.0/(1.0 + 0.2316419*x);
    const double k_sum =
    k * (0.319381530 + k * (-0.356563782 +
            k * (1.781477937 + k * (-1.821255978 + k * 1.330274429))));

    if (x &gt;= 0.0) {
        return (1.0 - (1.0/(pow(2*M_PI,0.5)))*exp(-0.5*x*x) * k_sum);
    } else {
        return 1.0 - norm_cdf(-x);
    }
}
    </code></pre>
    <p> Or .. </p>
    <pre class="fragment"><code class="c++" data-noescape>
// we can use the implemented function erfc
double norm_cdf(double value)
{
   return 0.5 * erfc(-value * M_SQRT1_2);
}
    </code></pre>
  </section>

  <section>
    <pre><code class="c++" data-noescape>
// This calculates d_j, for j in {1,2}. This term appears in the closed
// form solution for the European call or put price
double d_j(int j, double S, double K, double r, double v, double T) {
    return (log(S/K) + (r + (pow(-1,j-1))*0.5*v*v)*T)/(v*(pow(T,0.5)));
}

// Calculate the European vanilla call price based on
// underlying S, strike K, risk-free rate r, volatility of
// underlying sigma and time to maturity T
double call_price(double S, double K, double r, double v, double T) {
    return + S * norm_cdf(d_j(1, S, K, r, v, T))
           - K * exp(-r*T) * norm_cdf(d_j(2, S, K, r, v, T));
}

// Calculate the European vanilla put price based on
// underlying S, strike K, risk-free rate r, volatility of
// underlying sigma and time to maturity T
double put_price(double S, double K, double r, double v, double T) {
    return - S * norm_cdf(-d_j(1, S, K, r, v, T))
           + K * exp(-r*T) * norm_cdf(-d_j(2, S, K, r, v, T));
}
    </code></pre>
  </section>


  <section>
    <pre><code class="c++" style="font-size:14px; line-height: 14px; max-height: 850px;" data-noescape>
#include &lt;iostream&gt;
#include &lt;cmath&gt;

double norm_pdf(double x) {
    return (1.0/(pow(2*M_PI,0.5)))*exp(-0.5*x*x);
}
double norm_cdf(double value) {
   return 0.5 * erfc(-value * M_SQRT1_2);
}
double d_j(int j, double S, double K, double r, double v, double T) {
    return (log(S/K) + (r + (pow(-1,j-1))*0.5*v*v)*T)/(v*(pow(T,0.5)));
}
double call_price(double S, double K, double r, double v, double T) {
    return + S * norm_cdf(d_j(1, S, K, r, v, T))
           - K * exp(-r*T) * norm_cdf(d_j(2, S, K, r, v, T));
}
double put_price(double S, double K, double r, double v, double T) {
    return - S * norm_cdf(-d_j(1, S, K, r, v, T))
           + K * exp(-r*T) * norm_cdf(-d_j(2, S, K, r, v, T));
}
int main() {
    // First we create the parameter list
    double S = 100.0;  // Option price
    double K = 100.0;  // Strike price
    double r = 0.05;   // Risk-free rate (5%)
    double v = 0.2;    // Volatility of the underlying (20%)
    double T = 1.0;    // One year until expiry

    // Then we calculate the call/put values
    double call = call_price(S, K, r, v, T);
    double put = put_price(S, K, r, v, T);

    // Finally we output the parameters and prices
    std::cout &lt;&lt; "Underlying:      " &lt;&lt; S &lt;&lt; std::endl;
    std::cout &lt;&lt; "Strike:          " &lt;&lt; K &lt;&lt; std::endl;
    std::cout &lt;&lt; "Risk-Free Rate:  " &lt;&lt; r &lt;&lt; std::endl;
    std::cout &lt;&lt; "Volatility:      " &lt;&lt; v &lt;&lt; std::endl;
    std::cout &lt;&lt; "Maturity:        " &lt;&lt; T &lt;&lt; std::endl;

    std::cout &lt;&lt; "Call Price:      " &lt;&lt; call &lt;&lt; std::endl;
    std::cout &lt;&lt; "Put Price:       " &lt;&lt; put &lt;&lt; std::endl;

    return 0;
}
    </code></pre>

    <p class="fragment">Lets refactor this ... </p>
  </section>

  <section>
    <pre><code class="c++" data-noescape>
// main.cpp
#include "EuroOption.hpp"
int main() {
    EuroOption option{100.0, 100.0, 0.05, 0.2, 1.0};

    std::cout &lt;&lt; "Underlying:      " &lt;&lt; option.S &lt;&lt; std::endl;
    std::cout &lt;&lt; "Strike:          " &lt;&lt; option.K &lt;&lt; std::endl;
    std::cout &lt;&lt; "Risk-Free Rate:  " &lt;&lt; option.r &lt;&lt; std::endl;
    std::cout &lt;&lt; "Volatility:      " &lt;&lt; option.v &lt;&lt; std::endl;
    std::cout &lt;&lt; "Maturity:        " &lt;&lt; option.T &lt;&lt; std::endl;

    std::cout &lt;&lt; "Call Price:      " &lt;&lt; option.call_price() &lt;&lt; std::endl;
    std::cout &lt;&lt; "Put Price:       " &lt;&lt; option.put_price() &lt;&lt; std::endl;

    return 0;
}
    </code></pre>
  </section>

  <section>
    <pre><code class="c++" data-noescape>
// Utils.hpp
#include &lt;iostream&gt;
#include &lt;cmath&gt;
namespace utils {
    double norm_pdf(double x) { /* implementation */ }
    double norm_cdf(double value) { /* implementation */ }
    double d_j(/* params */) { /* implementation */ }
}
    </code></pre>
  </section>

  <section>
    <pre><code class="c++" data-noescape>
// EuroOption.hpp
#include "Utils.hpp"
class EuroOption {
public:
    double S, K, r, v, T;

    EuroOption(double S, double K, double r, double v, double T)
    : S(S), K(K), r(r), v(v), T(T) { }

    double call_price() const {
        return + S * utils::norm_cdf(utils::d_j(1, S, K, r, v, T))
               - K * exp(-r*T) * utils::norm_cdf(
                   + utils::d_j(2, S, K, r, v, T)
               );
    }

    double put_price() const {
        return - S * utils::norm_cdf(-utils::d_j(1, S, K, r, v, T))
               + K * exp(-r*T) * utils::norm_cdf(
                   - utils::d_j(2, S, K, r, v, T)
               );
    }
};
    </code></pre>
  </section>

  <section>
    <h3>Javascript  <span style="font-family:initial;">( ͡° ͜ʖ ͡°)</span></h3>
    <pre class="fragment"><code class="cs" data-noescape>
db.run(`create table if not exists user (
               id integer primary key autoincrement not null,
               age int,
               name text,
               weight real
            );`); </code></pre>
    <pre class="fragment"><code class="cs" data-noescape>
var stmt = db.prepare(`insert into user (age,name,weight) values (?,?,?);`);

stmt.run(21,  'joey',     80);
stmt.run(22,  'chandler', 65);
stmt.run(23,  'monica',   50);
stmt.run(24,  'ross',     75);
stmt.run(25,  'phoebe',   45);
stmt.run(26,  'rachel',   50);

stmt.finalize(); </code></pre>
    <pre class="fragment"><code class="cs" data-noescape>
db.each('select * from user', function(err, row) {
    console.log(row.age, row.name, row.weight);
});
</code></pre>
  </section>

  <section>
    <h3>C/C++ ಠ_ಠ</h3>
    <pre class="fragment"><code class="cs" data-noescape>
sqlite3* db;
sqlite3_open(":memory:", &amp;db);

const char * query = "create table if not exists user ("
          "   _id integer primary key autoincrement not null,"
          "   age int,"
          "   name text,"
          "   weight real"
          ");";
sqlite3_exec(db, query , 0, 0, nullptr);
</code></pre>
    <pre class="fragment"><code class="cs" data-noescape>
sqlite3_stmt *stmt;
sqlite3_prepare(db, "insert into user (age,name,weight) values (?,?,?);",
                -1, &amp;stmt, 0);
if(sqlite3_bind_int(stmt, 1, 21) != SQLITE_OK) return 1;
sqlite3_bind_text (stmt, 2, "chandler", -1, SQLITE_STATIC);
sqlite3_bind_double(stmt, 3, 70.0);
</code></pre>
    <pre class="fragment"><code class="cs" data-noescape>
sqlite3_step(stmt);
sqlite3_reset(stmt);
sqlite3_finalize(stmt);
</code></pre>
  </section>

  <section>
    <h3>(⊙︿⊙)</h3>
    <pre><code class="cs" data-noescape>
sqlite3_prepare( db, "select * from user", -1, &stmt, 0);
while(sqlite3_step(stmt) == SQLITE_ROW) {
  int age = sqlite3_column_int(stmt, 1);
  sqlite3_column_bytes(stmt, 2);
  string name = string(reinterpret_cast<char const *>(sqlite3_column_text(stmt, 2)));
  double weight = sqlite3_column_double(stmt, 3);
  cout << age << ", " << name << ", " << weight << endl;
}
sqlite3_finalize(stmt);
</code></pre>
    <h2 class="fragment"><br/>Can we do better?</h2>
    <h2 class="fragment">YES!</h2>
  </section>

  <section>
    <h3>C++ Templates</h3>
<pre class="fragment"><code class="c++" data-noescape>
template&lt;typename T&gt;
void Swap(T &amp; a, T &amp; b) { //"&amp;" passes parameters by reference
   T temp = b;
   b = a;
   a = temp;
}
</code></pre>
<pre class="fragment"><code class="c++" data-noescape>
template &lt;unsigned int n&gt;
struct factorial {
    enum { value = n * factorial<n - 1>::value };
};

template &lt;&gt;
struct factorial&lt;0&gt; {
    enum { value = 1 };
};

// factorial<0>::value would yield 1.
// factorial<4>::value would yield 24. </code></pre>
  </section>

  <section>
    <h3>C++ Metaprogramming</h3>
    <pre><code style="max-height:800px;" class="c++" data-noescape>
template &lt;int p, int i&gt;
class check_prime {
  public:
   enum { prim = ( (p % i) &amp;&amp; check_prime&lt;p, i - 1&gt;::prim ) };
};

template &lt;int p&gt;
class check_prime&lt;p, 1&gt; {
  public:
      enum { prim = 1 };
};

template&lt;int n&gt;
class is_prime {
  public:
  enum { value = check_prime&lt;n,n-1&gt;::prim };
};

int main() {
  bool is_prime_17 = is_prime&lt;17&gt;::value; // 1
  bool is_prime_20 = is_prime&lt;20&gt;::value; // 0
}
</code></pre>
  </section>

  <section>
    <h2>Why?</h3>
    <img src="linker.png" style="zoom:70%; border:none" />
  </section>

  <section>
    <h3>Solution</h3>
    <h3><a href="https://github.com/aminroosta/sqlite_modern_cpp">Sqlite Modern Cpp</a></h3>
    <img src="google.png" style="zoom:70%; border:none" />
  </section>

  <section>
    <h3>(▰˘◡˘▰)</h3>
    <img src="modern-cpp-1.png" style="zoom:80%; border:none" />
    <p>Pretty easy</p>
  </section>

  <section>
    <h3>ಠ_ಥ</h3>
    <img src="modern-cpp-2.png" style="zoom:80%; border:none" />
    <p>Hard but doable in C++</p>
  </section>

  <section>
    <h3>(ಥ﹏ಥ)</h3>
    <img src="modern-cpp-3.png" style="zoom:80%; border:none" />
    <p>Needs Magic!</p>
  </section>

  <section>
    <h3>Magic ¯\(°_o)/¯</h3>
    <img src="magic.png" style="zoom:55%; border:none" />
  </section>

  <section>
    <h3>More Magic ¯\_(ツ)_/¯</h3>
    <img src="more-magic.png" style="zoom:50%; border:none" />
  </section>

  <section>
    <h1>QA?</h1>
  </section>

                        </div>
                </div>

                <script src="lib/js/head.min.js"></script>
                <script src="js/reveal.js"></script>

                <script>
                        // More info https://github.com/hakimel/reveal.js#configuration
                        Reveal.initialize({

                                controls: false, // Display controls in the bottom right corner
                                progress: true, // Display a presentation progress bar
                                history: true, // Push each slide change to the browser history
                                keyboard: true, // Enable keyboard shortcuts for navigation
                                overview: true, // Enable the slide overview mode
                                center: true, // Vertical centering of slides
                                touch: true,
                                loop: false,
                                rtl: false,
                                shuffle: false,
                                fragments: true, // Turns fragments on and off globally
                                help: true, // Flags if we should show a help overlay when the questionmark key is pressed
                                showNotes: false, // Flags if speaker notes should be visible to all viewers
                                autoSlide: 0,
                                autoSlideStoppable: true, // Stop auto-sliding after user input
                                autoSlideMethod: Reveal.navigateNext,
                                mouseWheel: false,
                                hideAddressBar: true,
                                previewLinks: false, // Opens links in an iframe preview overlay
                                transition: 'default', // none/fade/slide/convex/concave/zoom
                                transitionSpeed: 'default', // default/fast/slow
                                backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom
                                viewDistance: 3, // Number of slides away from the current that are visible
                                //parallaxBackgroundImage: 'bg.jpg',
                                //parallaxBackgroundSize: '2559px 1510px', // CSS syntax, e.g. "2100px 900px"
                                // Number of pixels to move the parallax background per slide
                                // - Calculated automatically unless specified
                                // - Set to 0 to disable movement along an axis
                                parallaxBackgroundHorizontal: null,
                                parallaxBackgroundVertical: null,

                                // More info https://github.com/hakimel/reveal.js#dependencies
                                dependencies: [
                                        { src: 'plugin/markdown/marked.js' },
                                        { src: 'plugin/markdown/markdown.js' },
                                        { src: 'plugin/notes/notes.js', async: true },
                                        { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                                ]
                        });
                </script>
        </body>
</html>
